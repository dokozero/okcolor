"use strict";let l="fill",h,p=!1,e={hasFillStroke:{fill:!1,stroke:!1},colors:{fill:{rgba:[255,255,255,0]},stroke:{rgba:[255,255,255,0]}}};const C=function(){e.hasFillStroke.fill=!1,e.hasFillStroke.stroke=!1,e.colors.fill.rgba=[255,255,255,0],e.colors.stroke.rgba=[255,255,255,0]},k=function(){var u,n;C();const o=["BOOLEAN_OPERATION","COMPONENT","ELLIPSE","FRAME","INSTANCE","LINE","POLYGON","RECTANGLE","STAR","TEXT","VECTOR","SHAPE_WITH_TEXT","HIGHLIGHT"],s=figma.currentPage.selection;if(!s[0])return f("noSelection"),!1;for(const i of s)if(!o.includes(i.type))return f("notSupportedType",i.type),!1;const r=s[0].fills[0],t=s[0].strokes[0];if(!r&&!t)return f("noColorInShape"),!1;if((r==null?void 0:r.type)!=="SOLID"&&(t==null?void 0:t.type)!=="SOLID")return f("noSolidColor"),!1;if((r==null?void 0:r.type)==="SOLID"&&(e.hasFillStroke.fill=!0,e.colors.fill.rgba[0]=r.color.r*255,e.colors.fill.rgba[1]=r.color.g*255,e.colors.fill.rgba[2]=r.color.b*255,e.colors.fill.rgba[3]=Math.round(r.opacity*100)),(t==null?void 0:t.type)==="SOLID"&&(e.hasFillStroke.stroke=!0,e.colors.stroke.rgba[0]=t.color.r*255,e.colors.stroke.rgba[1]=t.color.g*255,e.colors.stroke.rgba[2]=t.color.b*255,e.colors.stroke.rgba[3]=Math.round(t.opacity*100)),s.length>1){let i=0,a=0;for(const S of s)((u=S.fills[0])==null?void 0:u.type)==="SOLID"&&i++,((n=S.strokes[0])==null?void 0:n.type)==="SOLID"&&a++;if(s.length!==i&&s.length!==a)return f("notAllShapesHaveFillOrStroke"),!1;a<i?e.hasFillStroke.stroke=!1:i<a&&(e.hasFillStroke.fill=!1)}return!0},d=function(){figma.ui.postMessage({message:"init",currentColorModel:h})},c=function(o=!1){figma.ui.postMessage({message:"newShapeColor",shapeInfos:e,currentFillOrStroke:l,shouldRenderColorPickerCanvas:o})},f=function(o,s=""){figma.ui.postMessage({message:"displayUIMessage",UIMessageCode:o,nodeType:s})};figma.showUI(__html__,{width:240,height:346,themeColors:!0});const y=async function(){h=await figma.clientStorage.getAsync("currentColorModel")||"okhsl",d(),k()&&(e.hasFillStroke.fill?l="fill":l="stroke",c(!0))};y();figma.on("selectionchange",()=>{l="fill",k()&&(l==="fill"&&!e.hasFillStroke.fill?l="stroke":l==="stroke"&&!e.hasFillStroke.stroke&&(l="fill"),c(!0))});figma.on("documentchange",o=>{if(p)return;if(o.documentChanges[0].type==="PROPERTY_CHANGE"){const r=o.documentChanges[0].properties[0];if(r==="fills"||r==="strokes"){let t=Object.assign({},e.hasFillStroke);if(!k())return;if(JSON.stringify(t)!==JSON.stringify(e.hasFillStroke)){l==="fill"&&!e.hasFillStroke.fill?l="stroke":l==="stroke"&&!e.hasFillStroke.stroke&&(l="fill"),c(!0);return}l==="fill"&&r==="strokes"||l==="stroke"&&r==="fills"?c():c(!0)}}});let g;figma.ui.onmessage=o=>{if(o.type==="updateShapeColor"){p=!0;const s=o.newColor[0]/255,r=o.newColor[1]/255,t=o.newColor[2]/255,u=o.newColor[3]/100;let n;const i=l+"s";for(const a of figma.currentPage.selection)i in a&&(n=JSON.parse(JSON.stringify(a[i])),n[0].color.r=s,n[0].color.g=r,n[0].color.b=t,n[0].opacity=u,a[i]=n);g&&clearTimeout(g),g=setTimeout(()=>{p=!1},500)}else o.type==="syncCurrentFillOrStroke"?l=o.currentFillOrStroke:o.type==="syncCurrentColorModel"&&figma.clientStorage.setAsync("currentColorModel",o.currentColorModel)};
